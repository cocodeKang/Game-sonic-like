<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Sonic-like 액션 게임 - 최종 확장판</title>
  <style>
    /* 전체 화면 꽉 채우기 */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87CEEB;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    /* ========== 캔버스 및 스케일 관련 ========== */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    // 기준 게임월드 해상도 (좌표계)
    const baseWidth = 800, baseHeight = 400;
    function getScale() {
      return Math.min(canvas.width / baseWidth, canvas.height / baseHeight);
    }

    /* ========== 글로벌 상수 및 이미지 로드 ========== */
    const baseSpeed = 5;
    const baseJump = 15;
    const baseGravity = 0.8;
    let currentGravity = baseGravity;

    // 게임 시작시간 (플레이 타임 측정)
    const gameStartTime = Date.now();

    // 플레이어 이미지 (소닉)
    const playerImage = new Image();
    playerImage.src = "https://img.icons8.com/?size=512&id=91653&format=png";

    // 몬스터 이미지들
    const monster1Image = new Image();
    monster1Image.src = "https://cdn-icons-png.flaticon.com/512/4925/4925647.png";
    const monster2Image = new Image();
    monster2Image.src = "https://cdn-icons-png.flaticon.com/256/826/826610.png";
    const monster3Image = new Image();
    monster3Image.src = "https://cdn-icons-png.flaticon.com/512/1236/1236448.png";
    // 보스 이미지 (보스는 기본 몬스터보다 4~5배 크게)
    const bossImage = new Image();
    bossImage.src = "https://files.softicons.com/download/web-icons/character-icons-by-martin-berube/png/256x256/Monster.png";
    // 포털(텔레포트) 이미지
    const teleportImage = new Image();
    teleportImage.src = "https://cdn-icons-png.flaticon.com/512/8033/8033960.png";

    // 상점 메뉴 (추가: 권총, 더블점프)
    const shopMenu = [
      { name: "방구물약", price: 700, id: "fart", img: "https://via.placeholder.com/50?text=Fart" },
      { name: "스피드 물약", price: 500, id: "speed", img: "https://via.placeholder.com/50?text=Speed" },
      { name: "점프물약", price: 700, id: "jump", img: "https://via.placeholder.com/50?text=Jump" },
      { name: "날개물약", price: 1000, id: "wing", img: "https://via.placeholder.com/50?text=Wing" },
      { name: "권총", price: 800, id: "pistol", img: "https://via.placeholder.com/50?text=Pistol" },
      { name: "더블점프", price: 900, id: "doublejump", img: "https://via.placeholder.com/50?text=DoubleJump" },
      { name: "상점 종료" }
    ];

    /* ========== 게임 전역 변수들 ========== */
    let stage = 1;
    let score = 0;  // 코인 및 포털 도달 시 100점씩 추가 (상점 재화)
    let inShop = false;  // 상점 모드 여부
    let shopSelection = 0; // 상점 메뉴 선택 인덱스

    // 인벤토리 (최대 10슬롯, 구매한 아이템은 사라지지 않음)
    let inventory = [];  // 각 원소: { id:"...", name:"...", img:"..." }

    // 레벨 관련 객체들
    let platforms = [];      // 공중 발판들
    let coins = [];          // 코인들
    let groundSegments = []; // 땅 구간들 (type: "safe", "pit", "spike")
    let monsters = [];       // 일반 몬스터들 (각 객체에 monsterType: 1,2,3)
    let monsterMissiles = []; // 타입3 몬스터가 발사하는 미사일들
    let boss = null;         // 보스 (스테이지 10마다 등장)
    let bossMissiles = [];   // 보스 미사일들
    let bullets = [];        // 플레이어 총알들 (권총 발사용)
    let teleport = null;     // 텔레포트(포털) 오브젝트

    // 플레이어 객체 (기본 좌표는 기준 좌표계 기준)
    let player = {
      x: 50,
      y: baseHeight - 60,
      width: 40,
      height: 40,
      vx: 0,
      vy: 0,
      // 기본적으로 단일 점프만 가능; 더블점프 구매 후 활성화
      jumpsLeft: 1,
      facing: 1,  // 1: 오른쪽, -1: 왼쪽
      health: 3,  // 스테이지마다 3 하트
      invincibleUntil: 0, // 피해 후 무적 타이머
      doubleJumpEnabled: false // 기본 비활성 (상점 구매로 활성화)
    };

    // 아이템(포션) 효과 – 만료 시각 (ms); 구매한 효과들은 스테이지 넘어가도 유지됨
    let powerUps = {
      fart: 0,
      speed: 0,
      jump: 0,
      wing: 0
    };

    // 레벨 너비 (게임월드 좌표)
    let levelWidth = 2000;

    // 입력 상태
    let keys = {};
    window.addEventListener("keydown", e => { keys[e.code] = true; });
    window.addEventListener("keyup", e => { keys[e.code] = false; });

    let jumpPressed = false;  // 중복 점프 입력 방지

    /* ========== 무기 관련 변수 ========== */
    // --- 검 (기본 무기) 공격 (키 "Digit1") ---
    let swordCooldown = 0;
    let swordAttackActive = false;
    let swordAttackEndTime = 0;
    let swordHitbox = null;  // { x, y, width, height }
    let swordInputLocked = false; // 한 번만 처리

    // --- 권총 (구매 시 인벤토리에 추가됨) ---
    let pistolAmmo = 6;
    let pistolLastShotTime = 0;
    let pistolReloading = false;
    let pistolReloadEndTime = 0;
    const pistolFireDelay = 300; // ms
    const pistolReloadTime = 2000; // ms

    /* ========== 유틸리티 함수 ========== */
    function rectsOverlap(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    // 땅(segment) 검색
    function getGroundSegment(x) {
      for (let seg of groundSegments) {
        if (x >= seg.x && x < seg.x + seg.width) return seg;
      }
      return null;
    }
    // x 좌표의 땅 높이 (safe 또는 spike이면 baseHeight-20)
    function getGroundY(x) {
      let seg = getGroundSegment(x);
      if (seg && (seg.type === "safe" || seg.type === "spike")) {
        return baseHeight - 20;
      }
      return null;
    }

    // 피해 함수 – 무적 타이머를 적용하여 1회에 1하트씩 감소
    function takeDamage() {
      const now = Date.now();
      if (now < player.invincibleUntil) return;
      player.health -= 1;
      player.invincibleUntil = now + 1000; // 1초 무적
      // (원한다면 간단한 효과나 사운드 재생)
      if (player.health <= 0) {
        death();
      }
    }

    // 사망 처리 – 스테이지를 재시작하고 하트 회복 (점수와 인벤토리는 유지)
    function death() {
      console.log("플레이어 사망! 스테이지 " + stage + "에서 재시작");
      // 재시작 시 하트 3개 회복
      player.health = 3;
      // 플레이어 위치 재설정 (상점이면 중앙, 아니면 시작 영역)
      if (inShop) {
        player.x = baseWidth / 2 - player.width / 2;
        player.y = baseHeight - 60;
      } else {
        player.x = 50;
        let gY = getGroundY(player.x + player.width/2);
        player.y = (gY !== null ? gY - player.height : baseHeight - 60);
      }
      player.vx = 0;
      player.vy = 0;
      // 리셋 후 무적 타이머 초기화
      player.invincibleUntil = Date.now() + 1000;
    }

    /* ========== 스테이지 로드 함수 ========== */
    // 스테이지 1은 특별하게 구성, 상점은 5스테이지마다, 보스는 10스테이지마다 (보스 > 상점)
    function loadStage(s) {
      // 초기화
      platforms = [];
      coins = [];
      groundSegments = [];
      monsters = [];
      monsterMissiles = [];
      boss = null;
      bossMissiles = [];
      bullets = [];
      teleport = null;

      // 1스테이지: 간단한 safe 땅, 낮은 플랫폼, 포털이 눈에 보임
      if (s === 1) {
        levelWidth = 800;
        groundSegments = [{ x: 0, width: levelWidth, type: "safe" }];
        platforms = [{ x: levelWidth - 200, y: baseHeight - 60, width: 100, height: 10 }];
        teleport = { x: levelWidth - 200, y: baseHeight - 60 - 50, width: 50, height: 50 };
        coins = [];
        for (let i = 0; i < 3; i++) {
          let coinX = Math.random() * (levelWidth - 200) + 200;
          let coinY = baseHeight - 100;
          coins.push({ x: coinX, y: coinY, radius: 10, collected: false });
        }
        monsters = [];
        // 예시로 하나의 기본 몬스터 배치 (x>=300)
        monsters.push({ x: 400, y: baseHeight - 20 - 30, width: 30, height: 30, vx: baseSpeed, monsterType: 1 });
        // 플레이어 위치 초기화, 하트 회복
        player.x = 50;
        player.y = baseHeight - 60;
        player.vx = 0;
        player.vy = 0;
        player.jumpsLeft = 1; // 더블점프 비활성
        player.health = 3;
        return;
      }

      // 상점 모드: 5스테이지마다 (단, 보스 스테이지 제외)
      if (s % 10 === 0) {
        inShop = false;
      } else if (s % 5 === 0) {
        inShop = true;
      } else {
        inShop = false;
      }
      if (inShop) {
        player.x = baseWidth / 2 - player.width / 2;
        player.y = baseHeight - 60;
        player.vx = 0;
        player.vy = 0;
        player.jumpsLeft = (player.doubleJumpEnabled ? 2 : 1);
        return;
      }

      // 일반 또는 보스 스테이지 구성
      levelWidth = 2000 + s * 50;

      // 1. groundSegments 생성  
      let x = 0;
      while (x < levelWidth) {
        let segWidth = Math.floor(Math.random() * 100) + 100;
        if (x < 200) {
          groundSegments.push({ x: x, width: segWidth, type: "safe" });
        } else {
          let pitChance = Math.min(0.1 + s * 0.01, 0.3);
          let spikeChance = Math.min(0.1 + s * 0.01, 0.3);
          let rnd = Math.random();
          if (rnd < pitChance) {
            groundSegments.push({ x: x, width: segWidth, type: "pit" });
          } else if (rnd < pitChance + spikeChance) {
            groundSegments.push({ x: x, width: segWidth, type: "spike" });
          } else {
            groundSegments.push({ x: x, width: segWidth, type: "safe" });
          }
        }
        x += segWidth;
      }

      // 2. 플랫폼 생성 (5~10개)
      let platCount = Math.floor(Math.random() * 6) + 5;
      let currentX = 300;
      for (let i = 0; i < platCount; i++) {
        let gap = Math.floor(Math.random() * 150) + 100;
        currentX += gap;
        let y = Math.floor(Math.random() * (baseHeight - 150)) + 50;
        platforms.push({ x: currentX, y: y, width: 100, height: 10 });
      }

      // 3. 코인 생성 (3~7개; x<200 제외)
      coins = [];
      let coinCount = Math.floor(Math.random() * 5) + 3;
      for (let i = 0; i < coinCount; i++) {
        let coinX = Math.random() * (levelWidth - 200) + 200;
        let coinY = Math.random() * (baseHeight - 200) + 50;
        coins.push({ x: coinX, y: coinY, radius: 10, collected: false });
      }

      // 4. 텔레포트 생성 (마지막 safe 구간 중앙)
      let lastSafe = null;
      for (let seg of groundSegments) {
        if (seg.type === "safe") lastSafe = seg;
      }
      if (!lastSafe) lastSafe = groundSegments[groundSegments.length - 1];
      teleport = { x: lastSafe.x + lastSafe.width / 2 - 25, y: baseHeight - 20 - 50, width: 50, height: 50 };

      // 5. 몬스터 생성  
      if (s % 10 === 0) {
        // 보스 스테이지: 보스는 4~5배 크게
        boss = {
          x: levelWidth - 300,
          y: baseHeight - 20 - 150,
          width: 150,
          height: 150,
          health: 10 + s,
          vx: -1,
          missileTimer: Date.now() + 2000
        };
        bossMissiles = [];
      } else {
        let monsterCount = Math.floor(s / 2) + 1;
        for (let i = 0; i < monsterCount; i++) {
          let mX = Math.random() * ((levelWidth * 0.9) - 300) + 300;
          let mY = baseHeight - 20 - 30;
          let mSpeed = (Math.random() * 2 + 1) + s * 0.1;
          let rndType = Math.random();
          let monsterType;
          if (rndType < 0.33) monsterType = 1;
          else if (rndType < 0.66) monsterType = 2;
          else monsterType = 3;
          let monster = {
            x: mX,
            y: mY,
            width: 30,
            height: 30,
            vx: (Math.random() < 0.5 ? -1 : 1) * mSpeed,
            monsterType: monsterType
          };
          if (monsterType === 2) {
            monster.jumpTimer = Date.now() + Math.random() * 2000 + 2000;
            monster.vy = 0;
          }
          if (monsterType === 3) {
            monster.missileTimer = Date.now() + Math.random() * 2000 + 3000;
          }
          monsters.push(monster);
        }
      }

      // 6. 플레이어 초기 배치 및 하트 회복
      player.x = 50;
      let gY = getGroundY(player.x + player.width/2);
      player.y = (gY !== null ? gY - player.height : baseHeight - 60);
      player.vx = 0;
      player.vy = 0;
      // 점프 횟수: 지면이면 (더블점프 활성화 여부에 따라 2 or 1)
      player.jumpsLeft = (player.doubleJumpEnabled ? 2 : 1);
      player.health = 3;
    }

    /* ========== 업데이트 함수 ========== */
    function update() {
      if (inShop) {
        updateShop();
      } else {
        updateGame();
      }
    }

    // 상점 업데이트: 화살표로 메뉴 이동, 엔터로 구매 또는 "상점 종료" 선택 시 다음 스테이지로
    function updateShop() {
      if (keys["ArrowUp"]) {
        shopSelection--;
        if (shopSelection < 0) shopSelection = shopMenu.length - 1;
        keys["ArrowUp"] = false;
      }
      if (keys["ArrowDown"]) {
        shopSelection++;
        if (shopSelection >= shopMenu.length) shopSelection = 0;
        keys["ArrowDown"] = false;
      }
      if (keys["Enter"]) {
        let selected = shopMenu[shopSelection];
        if (selected.name === "상점 종료") {
          stage++;
          loadStage(stage);
        } else {
          if (score >= selected.price) {
            score -= selected.price;
            // 구매한 아이템은 인벤토리에 추가 (중복 구매 가능하며 스테이지 넘어도 유지)
            inventory.push(selected);
            // 패시브 항목인 더블점프는 구매 즉시 효과 적용
            if (selected.id === "doublejump") {
              player.doubleJumpEnabled = true;
            }
            console.log(selected.name + " 인벤토리에 추가됨");
          } else {
            console.log("소지금 부족!");
          }
        }
        keys["Enter"] = false;
      }
    }

    // 일반 게임 업데이트
    function updateGame() {
      const now = Date.now();
      // 효과 적용
      let effectiveSpeed = (powerUps.speed > now) ? baseSpeed * 2 : baseSpeed;
      let effectiveJump = baseJump;
      if (powerUps.jump > now) effectiveJump = baseJump * 2;
      else if (powerUps.fart > now) effectiveJump = Math.floor(baseJump * 1.5);
      currentGravity = (powerUps.wing > now) ? 0 : ((powerUps.fart > now) ? 0.2 : baseGravity);

      // --- 무기 입력: 검 공격 (키 "Digit1") ---
      if (keys["Digit1"] && !swordInputLocked) {
        if (now > swordCooldown) {
          swordAttackActive = true;
          swordAttackEndTime = now + 200;  // 공격 지속 200ms
          swordCooldown = now + 500;       // 500ms 쿨타임
          // 검 히트박스: 플레이어 앞쪽 50px 영역 (수직은 플레이어와 같음)
          if (player.facing === 1) {
            swordHitbox = { x: player.x + player.width, y: player.y, width: 50, height: player.height };
          } else {
            swordHitbox = { x: player.x - 50, y: player.y, width: 50, height: player.height };
          }
          swordInputLocked = true;
        }
      }
      if (!keys["Digit1"]) { swordInputLocked = false; }
      if (swordAttackActive && now > swordAttackEndTime) {
        swordAttackActive = false;
        swordHitbox = null;
      }
      // --- 권총 발사: 마우스 좌클릭 처리 (아래 이벤트 핸들러 참조) ---
      // 재장전 처리
      if (pistolReloading && now > pistolReloadEndTime) {
        pistolAmmo = 6;
        pistolReloading = false;
      }

      // --- 플레이어 이동 ---
      if (keys["ArrowRight"] || keys["KeyD"]) {
        player.vx = effectiveSpeed;
        player.facing = 1;
      } else if (keys["ArrowLeft"] || keys["KeyA"]) {
        player.vx = -effectiveSpeed;
        player.facing = -1;
      } else {
        player.vx = 0;
      }

      // 점프: 더블점프는 활성화되어야 2회, 그렇지 않으면 1회
      if ((keys["ArrowUp"] || keys["KeyW"] || keys["Space"]) && !jumpPressed) {
        if (player.jumpsLeft > 0) {
          player.vy = -effectiveJump;
          player.jumpsLeft--;
          jumpPressed = true;
        }
      }
      if (!(keys["ArrowUp"] || keys["KeyW"] || keys["Space"])) {
        jumpPressed = false;
      }
      // 중력 또는 날개 효과
      if (powerUps.wing > now) {
        if (keys["ArrowUp"]) { player.y -= effectiveSpeed; }
        if (keys["ArrowDown"]) { player.y += effectiveSpeed; }
      } else {
        player.vy += currentGravity;
      }

      // 플레이어 위치 업데이트
      player.x += player.vx;
      player.y += player.vy;

      // 플랫폼 충돌 처리
      let landed = false;
      for (let plat of platforms) {
        if (
          player.x < plat.x + plat.width &&
          player.x + player.width > plat.x &&
          player.y + player.height > plat.y &&
          player.y + player.height - player.vy <= plat.y
        ) {
          player.y = plat.y - player.height;
          player.vy = 0;
          landed = true;
        }
      }
      // 땅(ground) 충돌 처리
      let gY = getGroundY(player.x + player.width/2);
      if (gY !== null) {
        let seg = getGroundSegment(player.x + player.width/2);
        // 가시면 바로 피해 (항상 하트 1 깎음)
        if (seg && seg.type === "spike") {
          // 단, 플레이어가 약간 뜬 상태가 아니라면 (차이가 10px 미만)
          if (player.vy >= 0 && (player.y + player.height - gY) < 10) {
            takeDamage();
          }
        }
        if (player.y + player.height > gY) {
          player.y = gY - player.height;
          player.vy = 0;
          landed = true;
        }
      }
      if (landed) {
        // 지면에 닿으면 점프 횟수 재설정 (더블점프 여부에 따라)
        player.jumpsLeft = (player.doubleJumpEnabled ? 2 : 1);
      }
      // 경계 처리
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > levelWidth) player.x = levelWidth - player.width;
      if (player.y > baseHeight) { takeDamage(); } // 낙하 시 피해

      // 코인 획득
      for (let coin of coins) {
        if (!coin.collected &&
            player.x < coin.x + coin.radius &&
            player.x + player.width > coin.x - coin.radius &&
            player.y < coin.y + coin.radius &&
            player.y + player.height > coin.y - coin.radius) {
          coin.collected = true;
          score += 100;
        }
      }

      // 텔레포트(포털) 충돌 – 도달 시 스테이지 클리어 및 하트 회복
      if (teleport &&
          player.x < teleport.x + teleport.width &&
          player.x + player.width > teleport.x &&
          player.y < teleport.y + teleport.height &&
          player.y + player.height > teleport.y) {
        score += 100;
        stage++;
        loadStage(stage);
        return;
      }

      // 몬스터 업데이트
      for (let m of monsters) {
        m.x += m.vx;
        if (m.x < 300 || m.x + m.width > levelWidth) { m.vx *= -1; }
        // 타입2: 주기적 점프
        if (m.monsterType === 2) {
          if (Date.now() > m.jumpTimer) {
            m.vy = -5;
            m.jumpTimer = Date.now() + (Math.random()*2000 + 2000);
          }
          m.vy = (m.vy || 0) + baseGravity;
          let groundY = baseHeight - 20;
          if (m.y + m.height + m.vy > groundY) {
            m.y = groundY - m.height;
            m.vy = 0;
          } else {
            m.y += m.vy;
          }
        }
        // 타입3: 주기적 미사일 발사
        if (m.monsterType === 3) {
          if (Date.now() > m.missileTimer) {
            let missileSpeed = 4;
            let angle = Math.atan2(player.y - m.y, player.x - m.x);
            let vx = missileSpeed * Math.cos(angle);
            let vy = missileSpeed * Math.sin(angle);
            monsterMissiles.push({ x: m.x + m.width/2, y: m.y + m.height/2, vx: vx, vy: vy, width: 10, height: 10 });
            m.missileTimer = Date.now() + (Math.random()*2000 + 3000);
          }
        }
        if (rectsOverlap(player, m)) { takeDamage(); }
      }

      // 몬스터 미사일 업데이트
      for (let i = monsterMissiles.length - 1; i >= 0; i--) {
        let missile = monsterMissiles[i];
        missile.x += missile.vx;
        missile.y += missile.vy;
        if (missile.x < 0 || missile.x > levelWidth || missile.y < 0 || missile.y > baseHeight) {
          monsterMissiles.splice(i, 1);
          continue;
        }
        if (rectsOverlap(player, missile)) { takeDamage(); }
      }

      // 보스 업데이트 (보스 스테이지)
      if (boss) {
        boss.x += boss.vx;
        if (boss.x < levelWidth - 600 || boss.x + boss.width > levelWidth - 200) {
          boss.vx *= -1;
        }
        if (now > boss.missileTimer) {
          let missileSpeed = 4;
          let angle = Math.atan2(player.y - boss.y, player.x - boss.x);
          let vx = missileSpeed * Math.cos(angle);
          let vy = missileSpeed * Math.sin(angle);
          bossMissiles.push({ x: boss.x + boss.width/2, y: boss.y + boss.height/2, vx: vx, vy: vy, width: 10, height: 10 });
          boss.missileTimer = now + 2000;
        }
        if (rectsOverlap(player, boss)) { takeDamage(); }
        for (let i = bossMissiles.length - 1; i >= 0; i--) {
          let missile = bossMissiles[i];
          missile.x += missile.vx;
          missile.y += missile.vy;
          if (missile.x < 0 || missile.x > levelWidth || missile.y < 0 || missile.y > baseHeight) {
            bossMissiles.splice(i, 1);
            continue;
          }
          if (rectsOverlap(player, missile)) { takeDamage(); }
        }
      }

      // 플레이어 총알 업데이트 (권총 발사)
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.x < 0 || b.x > levelWidth || b.y < 0 || b.y > baseHeight) {
          bullets.splice(i, 1);
          continue;
        }
        // 총알이 몬스터에 맞으면 제거
        for (let j = monsters.length - 1; j >= 0; j--) {
          if (rectsOverlap(b, monsters[j])) {
            monsters.splice(j, 1);
            bullets.splice(i, 1);
            break;
          }
        }
        if (boss && rectsOverlap(b, boss)) {
          boss.health -= 1;
          bullets.splice(i, 1);
          if (boss.health <= 0) {
            boss = null;
            bossMissiles = [];
          }
        }
      }

      // 검 공격 처리: 공격 활성 시 hitbox와 충돌하는 몬스터/보스 제거
      if (swordAttackActive && swordHitbox) {
        for (let i = monsters.length - 1; i >= 0; i--) {
          if (rectsOverlap(swordHitbox, monsters[i])) {
            monsters.splice(i, 1);
          }
        }
        if (boss && rectsOverlap(swordHitbox, boss)) {
          boss.health -= 1;
          if (boss.health <= 0) {
            boss = null;
            bossMissiles = [];
          }
        }
      }

      // 인벤토리 활성화 – (여기서는 무기 등 구매 아이템은 번호키로 발동)
      for (let key in keys) {
        if (keys[key] && key.startsWith("Digit")) {
          let num = parseInt(key.replace("Digit", ""));
          if (key === "Digit0") num = 10;
          let index = num - 1;
          if (index >= 0 && index < inventory.length) {
            let item = inventory[index];
            // 활성화: 구매한 물약 등 (효과는 계속 유지하도록; 여기서는 단순 재설정)
            powerUps[item.id] = Date.now() + 10000; // 10초 효과
            console.log(item.name + " 활성화!");
            // 활성화 후 인벤토리에서는 제거하지 않음 (요청: 스테이지 넘어도 유지)
            keys[key] = false;
          }
        }
      }
    }

    /* ========== 마우스 좌클릭: 권총 발사 (만약 인벤토리에 "pistol"이 있으면) ========== */
    canvas.addEventListener("mousedown", function(e) {
      if (!inShop && e.button === 0) {
        // 만약 인벤토리 중 pistol 아이템이 있으면 권총 발사
        let hasPistol = inventory.some(item => item.id === "pistol");
        if (hasPistol) {
          const now = Date.now();
          if (!pistolReloading && now - pistolLastShotTime > pistolFireDelay) {
            // 발사: 플레이어 중앙에서, 플레이어의 facing 방향으로 총알 생성
            let bulletSpeed = 10;
            let bullet = {
              x: player.x + player.width / 2,
              y: player.y + player.height / 2,
              width: 10,
              height: 5,
              vx: bulletSpeed * player.facing,
              vy: 0
            };
            bullets.push(bullet);
            pistolAmmo--;
            pistolLastShotTime = now;
            if (pistolAmmo <= 0) {
              pistolReloading = true;
              pistolReloadEndTime = now + pistolReloadTime;
            }
          }
        }
      }
    });

    /* ========== UI 그리기 함수 ========== */
    // 게임월드 UI (스케일 적용 전, 기준 좌표계)
    function drawGameWorld() {
      // 카메라: 플레이어 중심 (기준 해상도)
      let cameraX = player.x - baseWidth / 2;
      if (cameraX < 0) cameraX = 0;
      if (cameraX > levelWidth - baseWidth) cameraX = levelWidth - baseWidth;
      ctx.save();
      ctx.translate(-cameraX, 0);
      
      // 땅 그리기
      for (let seg of groundSegments) {
        if (seg.type === "safe") {
          ctx.fillStyle = "#654321";
          ctx.fillRect(seg.x, baseHeight - 20, seg.width, 20);
        } else if (seg.type === "spike") {
          ctx.fillStyle = "#654321";
          ctx.fillRect(seg.x, baseHeight - 20, seg.width, 20);
          ctx.fillStyle = "gray";
          let spikeCount = Math.floor(seg.width / 20);
          for (let i = 0; i < spikeCount; i++) {
            ctx.beginPath();
            let spikeX = seg.x + i * 20 + 10;
            let spikeY = baseHeight - 20;
            ctx.moveTo(spikeX - 5, spikeY);
            ctx.lineTo(spikeX, spikeY - 15);
            ctx.lineTo(spikeX + 5, spikeY);
            ctx.fill();
          }
        } else if (seg.type === "pit") {
          ctx.fillStyle = "#000";
          ctx.fillRect(seg.x, baseHeight - 20, seg.width, 20);
        }
      }
      
      // 플랫폼
      for (let plat of platforms) {
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      }
      
      // 코인
      for (let coin of coins) {
        if (!coin.collected) {
          ctx.fillStyle = "yellow";
          ctx.beginPath();
          ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // 텔레포트(포털)
      if (teleport) {
        ctx.drawImage(teleportImage, teleport.x, teleport.y, teleport.width, teleport.height);
      }
      
      // 몬스터
      for (let m of monsters) {
        if (m.monsterType === 1) {
          ctx.drawImage(monster1Image, m.x, m.y, m.width, m.height);
        } else if (m.monsterType === 2) {
          ctx.drawImage(monster2Image, m.x, m.y, m.width, m.height);
        } else if (m.monsterType === 3) {
          ctx.drawImage(monster3Image, m.x, m.y, m.width, m.height);
        }
      }
      
      // 몬스터 미사일
      for (let missile of monsterMissiles) {
        ctx.fillStyle = "orange";
        ctx.fillRect(missile.x, missile.y, missile.width, missile.height);
      }
      
      // 보스 및 보스 미사일
      if (boss) {
        ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
        ctx.fillStyle = "white";
        ctx.font = "16px Arial";
        ctx.fillText("HP: " + boss.health, boss.x, boss.y - 5);
      }
      for (let missile of bossMissiles) {
        ctx.fillStyle = "orange";
        ctx.fillRect(missile.x, missile.y, missile.width, missile.height);
      }
      
      // 총알
      for (let b of bullets) {
        ctx.fillStyle = "black";
        ctx.fillRect(b.x, b.y, b.width, b.height);
      }
      
      // 플레이어
      ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
      
      // 검 공격 hitbox (만약 활성 상태면)
      if (swordAttackActive && swordHitbox) {
        ctx.fillStyle = "rgba(255,0,0,0.3)";
        ctx.fillRect(swordHitbox.x, swordHitbox.y, swordHitbox.width, swordHitbox.height);
      }
      
      ctx.restore();
    }

    // 상단 좌측 UI: 스테이지, 플레이 타임 (작은 글씨)
    function drawTopLeftUI() {
      ctx.fillStyle = "black";
      ctx.font = "14px Arial";
      ctx.fillText("스테이지: " + stage, 10, 20);
      let playTime = Math.floor((Date.now() - gameStartTime) / 1000);
      ctx.fillText("플레이 타임: " + playTime + "초", 10, 40);
    }

    // 좌측 하단: 점수
    function drawBottomLeftUI() {
      ctx.fillStyle = "black";
      ctx.font = "16px Arial";
      ctx.fillText("점수: " + score, 10, baseHeight - 10);
    }

    // 우측 하단: 하트 (3칸)
    function drawBottomRightUI() {
      const heartSize = 20;
      const padding = 5;
      let startX = baseWidth - (heartSize + padding) * 3 - 10;
      let y = baseHeight - heartSize - 10;
      for (let i = 0; i < 3; i++) {
        ctx.strokeStyle = "red";
        ctx.strokeRect(startX + i * (heartSize + padding), y, heartSize, heartSize);
        if (i < player.health) {
          ctx.fillStyle = "red";
          ctx.fillRect(startX + i * (heartSize + padding) + 2, y + 2, heartSize - 4, heartSize - 4);
        }
      }
    }

    // UI 영역 (게임월드는 기준 baseHeight; 그 아래 영역에 인벤토리 등 별도 UI)
    function drawUI() {
      // 먼저, 게임월드 UI는 그려진 후 (스케일 적용 내부)
      drawTopLeftUI();
      drawBottomLeftUI();
      drawBottomRightUI();
    }

    // 인벤토리 UI: 화면 전체 (실제 캔버스 좌표)에서 게임월드 아래 영역에 그리기
    function drawInventoryUI() {
      // 게임월드가 baseHeight * scale만큼 사용됨
      let scaleFactor = getScale();
      let gameWorldPixelHeight = baseHeight * scaleFactor;
      let invY = gameWorldPixelHeight + 10;
      ctx.save();
      ctx.resetTransform();
      ctx.fillStyle = "black";
      ctx.font = "16px Arial";
      ctx.fillText("소지품:", 10, invY + 20);
      // 인벤토리 슬롯 10칸
      const slotSize = 40;
      const slotPadding = 10;
      let startX = 10;
      for (let i = 0; i < 10; i++) {
        ctx.strokeStyle = "black";
        ctx.strokeRect(startX + i * (slotSize + slotPadding), invY + 30, slotSize, slotSize);
        if (i < inventory.length) {
          let item = inventory[i];
          let img = new Image();
          img.src = item.img;
          ctx.drawImage(img, startX + i * (slotSize + slotPadding) + 5, invY + 35, slotSize - 10, slotSize - 10);
          ctx.fillStyle = "white";
          ctx.font = "12px Arial";
          let slotNumber = (i === 9) ? 0 : i + 1;
          ctx.fillText(slotNumber, startX + i * (slotSize + slotPadding) + slotSize - 12, invY + 30 + slotSize - 5);
        }
      }
      // 더블점프 아이콘: 오른쪽에 표시 (회색이면 비활성, 컬러면 활성)
      let djX = startX + 10 * (slotSize + slotPadding) + 20;
      ctx.strokeStyle = "black";
      ctx.strokeRect(djX, invY + 30, slotSize, slotSize);
      let djImg = new Image();
      // 만약 더블점프 활성화되어 있으면 컬러, 아니면 회색 처리 (여기서는 placeholder)
      djImg.src = player.doubleJumpEnabled ? "https://via.placeholder.com/50/00FF00?text=DJ" : "https://via.placeholder.com/50/888888?text=DJ";
      ctx.drawImage(djImg, djX + 5, invY + 35, slotSize - 10, slotSize - 10);
      ctx.fillStyle = "black";
      ctx.font = "12px Arial";
      ctx.fillText("더블점프", djX, invY + slotSize + 50);
      ctx.restore();
    }

    /* ========== 메인 그리기 함수 ========== */
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 배경 채우기
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 게임월드 그리기 (스케일 적용)
      let scaleFactor = getScale();
      ctx.save();
      ctx.scale(scaleFactor, scaleFactor);
      drawGameWorld();
      drawUI();
      ctx.restore();

      // 인벤토리 및 패시브 아이템 UI는 화면 전체 좌표 사용 (게임월드 외부)
      drawInventoryUI();
    }

    /* ========== 메인 게임 루프 ========== */
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ------------------------------
    // 마우스 좌클릭 이벤트: 권총 발사 (위의 updateGame()에서 처리)
    // ------------------------------

    // 초기 스테이지 로드 및 게임 시작
    loadStage(stage);
    gameLoop();
  </script>
</body>
</html>
